import os
import volatility.utils as utils
import volatility.debug as debug
import volatility.win32.tasks as tasks
import volatility.plugins.taskmods as taskmods
import volatility.constants as constants

try:
    import yara
    has_yara = True
except ImportError:
    has_yara = False


class BaseYaraScanner(object):
    """An address space scanner for Yara signatures."""
    overlap = 1024

    def __init__(self, address_space = None, rules = None):
        self.rules = rules
        self.address_space = address_space

    def scan(self, offset, maxlen):
        # Start scanning from offset until maxlen:
        i = offset

        if isinstance(self.rules, list):
            rules = self.rules
        else:
            rules = [self.rules]

        while i < offset + maxlen:
            # Read some data and match it.
            to_read = min(constants.SCAN_BLOCKSIZE + self.overlap, offset + maxlen - i)
            data = self.address_space.zread(i, to_read)
            if data:
                for rule in rules:
                    for match in rule.match(data = data):
                        # We currently don't use name or value from the
                        # yara results but they can be yielded in the
                        # future if necessary.
                        for moffset, _name, _value in match.strings:
                            if moffset < constants.SCAN_BLOCKSIZE:
                                yield match, moffset + i

            i += constants.SCAN_BLOCKSIZE

class VadYaraScanner(BaseYaraScanner):
    """A scanner over all memory regions of a process."""

    def __init__(self, task = None, **kwargs):
        """Scan the process address space through the Vads.

        Args:
          task: The _EPROCESS object for this task.
        """
        self.task = task
        BaseYaraScanner.__init__(self, address_space = task.get_process_address_space(), **kwargs)

    def scan(self, offset = 0, maxlen = None):

        if maxlen == None:
            vads = self.task.get_vads(skip_max_commit = True)
        else:
            filter = lambda x : x.Length < maxlen
            vads = self.task.get_vads(vad_filter = filter,
                skip_max_commit = True)

        for vad, self.address_space in vads:
            for match in BaseYaraScanner.scan(self, vad.Start, vad.Length):
                yield match

#--------------------------------------------------------------------------------
# WebInject
#--------------------------------------------------------------------------------

class WebInject(taskmods.DllList):
    "Scan process memory and extract WebInject targerts"

    def __init__(self, config, *args, **kwargs):
        taskmods.DllList.__init__(self, config, *args, **kwargs)

    def _compile_rules(self):
        """Compile the YARA rules

        @returns: a YARA object on which you can call 'match'

        This function causes the plugin to exit if the YARA
        rules have syntax errors or are not supplied correctly.
        """

        rules = None

        try:
            rules = yara.compile(sources = {
                            'webinject' : '''
                                          rule WebInject {
                                              meta:
                                                 description = "Extracts WebInject targets (URLs and regexes) from a browser mem dump"
                                                 author = "conand"

                                              strings:
                                                  $URL = /((http[s\*]?:\/\/)|\*)[\*\/.0-9a-zA-Z-#]*\.(com|it|org|nl|uk|es|ru|net|ae|fr|de|bg)[\*\/.0-9a-zA-Z-]*/ fullword 

                                              condition:
                                                  for any i in (1..#URL) : (@URL[i] < @URL[i-1] + 20)
                                          }
                                          '''
                            })
        except yara.SyntaxError, why:
            debug.error("Cannot compile rules: {0}".format(str(why)))

        return rules

    def _scan_process_memory(self, addr_space, rules):
        for task in self.filter_tasks(tasks.pslist(addr_space)):
            if str(task.ImageFileName) != "iexplore.exe":
                continue
            scanner = VadYaraScanner(task = task, rules = rules)
            for hit, address in scanner.scan(maxlen = 0x40000000):
                yield (task, address, hit, scanner.address_space.zread(address, 256))

    def calculate(self):
        if not has_yara:
            debug.error("Please install Yara from https://plusvic.github.io/yara/")

        addr_space = utils.load_as(self._config)
        rules = self._compile_rules()
        process_mem = self._scan_process_memory(addr_space, rules)

        for p in process_mem:
            yield p

    def render_text(self, outfd, data):
        outfd.write("WebInject URL extraction:\n\n")

        if not data:
            outfd.write("\nNo URL Found!\n")
        else:
            self.table_header(outfd, [("Process", "13"), ("Pid", "6"), ("URL regexp","150")])
            count = 0
            urls = list()

            for o, addr, hit, content in data:
                url = content[0:120].split(chr(0))[0]
                url = url.split(" ")[0]
                url = url.split("\t")[0]
                pid = o.UniqueProcessId
                if [pid, url] not in urls:
                    urls.append([pid, url])
                    self.table_row(outfd, o.ImageFileName, pid, url)
                    count +=1
            outfd.write("\n{0} WebInject targets extracted!\n".format(count))
